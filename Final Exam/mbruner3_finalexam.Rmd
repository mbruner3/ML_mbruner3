---
title: "Final Exam"
output: html_document
---

```{r}
rm(list=ls())
```

```{r, echo=FALSE}
library(caret)
library(tidyverse)
library(ISLR)
library(factoextra)
library(corrplot)
library(fpc)
```

```{r}
# loaded dataset and made the column types appropriate for the data in each column. However, columns 20 to 46 have the "%" symbol and I will remove that symbol and convert them to decimals later.
soap <- read_csv("BathSoap.csv", col_types = c("ffffffffffdiidid??d???????????????????????????"))
head(soap)
```


```{r, message=FALSE}
# Renaming columns so they are easier to work with.
soap %>% 
  rename(id = "Member id", 
         sec = SEC,
         feh = FEH,
         mt = MT,
         sex = SEX,
         age = AGE,
         edu = EDU,
         hs = HS,
         child = CHILD,
         cs = CS,
         affluence = "Affluence Index",
         num_brand = "No. of Brands",
         brand_runs = "Brand Runs",
         tot_vol = "Total Volume",
         num_trans = `No. of  Trans`,
         value = Value,
         trans_ovr_br = "Trans / Brand Runs",
         vol_tran = "Vol/Tran",
         ave_price = "Avg. Price",
         pur_vol_no_promo = "Pur Vol No Promo - %",
         pur_vol_promo = `Pur Vol Promo 6 %`,
         pur_vol_diff_promo = "Pur Vol Other Promo %",
         others_999 = "Others 999",
         br_57_144 = "Br. Cd. 57, 144") %>% 
  rename_at(vars(starts_with("Br. Cd. ")), 
            funs(str_replace(., "Br. Cd. ", "br_"))) %>% 
  rename_at(vars(starts_with("Pr Cat ")), funs(str_replace(., "Pr Cat ", "pr_cat_"))) %>% 
  rename_at(vars(starts_with("PropCat")), funs(str_replace(., "PropCat ", "prop_cat_"))) -> soap
```

```{r}
# Removing all the "%" symbols from columns 18 to 44 and converting them to decimals to represent "percent".
soap[, 20:46] %>% 
  mutate_all(funs(gsub("[[:punct:]]", "", .))) -> soap[, 20:46]

soap[,20:46] <- lapply(soap[,20:46], function(x) as.numeric(x)/100)

# Others 999 brand category is not in percentage but should be. The range is 0 to 10 and the data dictionary says that it should be a percent of volume. A max of 10 doesn't fit that definition. Going to assume that it wasn't converted to a decimal correctly. 
soap$others_999 <- soap$others_999/10
# The sum of the brand categories should total 1 and the mean should be around 1 if I am correct in the others 999 category being incorrectly calculated. 
mean(rowSums(soap[, 23:31]))
# the mean of the row sums for the brand categories is around 1 so the correction I made is the right decision.
```

```{r}
# Checking to see if there are any missing data in our df. 
colMeans(is.na(soap))
```


## Exploratory Data Analysis 
```{r}
summary(soap)

soap %>% 
  select(feh, mt, sex, edu, hs, cs) %>% 
  filter(feh == 0 & mt == 0 & sex == 0)
```

Many of the demographics are not specified across many of the same columns and since k-Means uses continuous variables, they are not important to the algorithm.

```{r, warning=FALSE}
soap[, 2:10] %>% 
  gather(key = Variable, value = Value) %>% 
  ggplot() +
    geom_histogram(aes(x = Value), fill = "steelblue", stat = "count") +
    facet_wrap(~Variable, scales='free') +
    theme_classic() +
    theme(aspect.ratio = 0.5, axis.title = element_blank(), panel.grid = element_blank()) 

soap[, 11:22] %>% 
  gather(key = Variable, value = Value) %>% 
  ggplot() +
    geom_histogram(aes(x = Value), fill = "steelblue") +
    facet_wrap(~Variable, scales='free') +
    theme_classic() +
    theme(aspect.ratio = 0.5, axis.title = element_blank(), panel.grid = element_blank()) 

soap[, 23:31] %>% 
  gather(key = Variable, value = Value) %>% 
  ggplot() +
    geom_histogram(aes(x = Value), fill = "steelblue") +
    facet_wrap(~Variable, scales='free') +
    theme_classic() +
    theme(aspect.ratio = 0.5, axis.title = element_blank(), panel.grid = element_blank()) 

soap[, 32:46] %>% 
  gather(key = Variable, value = Value) %>% 
  ggplot() +
    geom_histogram(aes(x = Value), fill = "steelblue") +
    facet_wrap(~Variable, scales='free') +
    theme_classic() +
    theme(aspect.ratio = 0.5, axis.title = element_blank(), panel.grid = element_blank()) 
```


**Histogram of Variables 2 to 10**
Most of the customers were age level 3 and 4. The child varialbe has the highest count at level 4 and then level 2. The cs level highest was level 1 and the edu variable has levels 4 and 5 mostly. feh was level 1 and 3. hs was between 3 to 6 and mt was 10. sec was all even in the distribution of counts and sex was 2.

**Histogram of Variables 11 to 22**
Affluence, ave_price, num_trans all seem fairly normally distributed. Affluence has many 0's included that seem that they are missing values so if you impute those values then I suspect the graph will seem more normal. Many of the other variables are skew negative like pur_vol_promo. Purchase volume decreased with promotion but the purchase volume without a promotion increased in volume. 

**Histogram of Variables 23 to 31**
br_57_144 has the most activity out of the brands but it could be that the combination of them caused the increase. Others_999 has a lot of activity but it could be due to representing a lot of different brands. 

**Histogram of Variables 32 to 46**
All other prop_cat seem to have as much activity as 1, 2, and 5. 
prop_cat_1, 2, & 5 need to look at closer.

## Outlier Inspection
```{r}
soap %>% 
  select(feh, mt, sex, edu, hs, cs, affluence) %>%
  filter(affluence == 0)
# Noticed that many of the same columns in the demographics section are also "0" the same as "affluence". I believe that due to the lack of demographic information they were unable to calculate the affluence level. That makes sense.

soap %>% 
  filter(brand_runs > 50) %>% 
  select(affluence, brand_runs, num_trans, vol_tran, ave_price)
# This seems good to me as the affluence level for most is mid-range to high, the number of transactions and total volume is also high so you would expect number of brand runs to be high as well.

soap %>% 
  filter(vol_tran > 1500) %>%
  select(affluence, value, num_trans, tot_vol, vol_tran, ave_price, num_trans) %>%
  mutate(vol_tran_check = tot_vol/num_trans)
# Everything seems okay with these, nothing that seems off or strange like an error in inputting value into df.

soap %>% 
  mutate(vol_tran_check = round(tot_vol/num_trans, 2)) %>% 
  filter(vol_tran == vol_tran_check) %>% 
  select(vol_tran, vol_tran_check)
# checking average volume per transaction to see if there are any calculation errors. 583 of 600 were the same value. Checking the 17 that were different.

soap %>% 
  mutate(vol_tran_check = round(tot_vol/num_trans, 2)) %>% 
  filter(vol_tran != vol_tran_check) %>% 
  select(vol_tran, vol_tran_check) # numbers seem fine, only error due to rounding differences. Nothing significant.
```

## Variable Correlations
```{r}
cont <- soap[, 11:46]
cc <- cor(soap[, 11:46], method = "pearson")
corrplot(cc, method = "circle", type = "lower")

soap %>% 
  ggplot(aes(color = affluence)) +
    geom_point(aes(x = brand_runs, y=num_brand))

soap %>% 
 ggplot(aes(color = affluence)) +
    geom_point(aes(x = brand_runs, y=num_trans))

soap %>% 
  ggplot(aes(color = affluence)) +
    geom_point(aes(x = brand_runs, y=num_brand))

soap %>% 
  ggplot(aes(color = affluence)) +
    geom_point(aes(x = tot_vol, y = value))

soap %>% 
 ggplot(aes(color = affluence)) +
    geom_point(aes(x = vol_tran, y = tot_vol))

soap %>% 
ggplot(aes(color = affluence)) +
    geom_point(aes(x = pr_cat_1, y = ave_price))

soap %>% 
  ggplot(aes(color = affluence)) +
    geom_point(aes(x = pr_cat_3, y = br_55))


soap %>% 
ggplot(aes(color = affluence)) +
    geom_point(aes(x = prop_cat_11, y = br_481))

soap %>% 
  ggplot() +
    geom_point(aes(x = prop_cat_13, y = br_24), color = "steelblue")

soap %>% 
  ggplot() +
    geom_point(aes(x = prop_cat_14, y = br_55), color = "steelblue")

soap %>% 
  ggplot() +
    geom_point(aes(x = prop_cat_14, y = pr_cat_3), color = "steelblue")
```

**Possible Relationships:**

1. Stronger positive relationships:
  + Brand runs and number of brands (The higher the brand runs, the higher the number different brands purchased.)
  + number of transactions and brand runs (the higher the brand runs the higher the number of transactions, which means the more transactions the higher the number of different brands, there is a positive correlation between those two as well.)
  + value and total volume (the higher the value the higher the volume, typically the larger weight costs more so that makes sense. Since these are different soap products that would make sense.)
  + Pr_cat_1 and ave_price (the higher the average price, the more of product category 1 is purchased.)
  + prop_cat_14 and br_55 (I am guessing this means that most likely br_55 is mostly in prop_cat_14, same conclusion for the next two brands below.)
  + prop_cat_11 and br_481
  + prop_cat_13 and br_24
  + prop_cat_3 and pr_cat_14 (proposition category 3 must sell mostly in the third price category.)

### Exploring Brand Loyalty
```{r}
library(matrixStats)

brand <- as.matrix(soap[23:31])
soap$br_max <- rowMaxs(brand) 

as.factor(if_else(condition = 
            soap$br_57_144 >= .9 | 
            soap$br_55 >=.9 |
            soap$br_272 >= .9 | 
            soap$br_286 >= .9 | 
            soap$br_24 >= .9 | 
            soap$br_481 >= .9 | 
            soap$br_352 >= .9 | 
            soap$br_5 >= .9 |
            soap$others_999 >= .9, 
          1, 
          0)) -> soap$br_loy_m1 # Represents all customers who purchased 90% or above volume of a specific brand. However, this measure is misleading as if a person only purchased 1 product of a specific brand, they would show as have 100% volume of that brand and would be included in this measure.

as.factor(if_else(condition = soap$brand_runs >= 3, # customers who had a brand run of 3 or more.
          1, 
          0)) -> soap$br_loy_m2 

as.factor(if_else(condition = soap$num_brand == 1 & soap$num_trans >= 3, 
          1, 
          0)) -> soap$br_loy_m3 # customers who only purchase one brand and have more than 3 transactions.

soap %>% 
  relocate(id, sec, feh, mt, sex, age, edu, hs, child, cs, br_loy_m1, br_loy_m2, br_loy_m3, affluence, num_brand, brand_runs, num_trans, tot_vol, value, trans_ovr_br, vol_tran, ave_price, pur_vol_no_promo, pur_vol_promo, pur_vol_diff_promo, br_max) -> soap
soap
```

### Normalization
```{r}
set.seed(15)
norm <- preProcess(soap[14:50], method = c("scale", "center"))
norm <- predict(norm, soap[14:50])
```

# Part 1: Purchasing Behavior
This segmentation is based upon the volume of purchase, the frequency of purchases, average price, the susceptibility to discounts, and the brand loyalty of a household. 

```{r}
purchase_behavior <- norm[, c(2:13)] # created a df based on purchase behavior variables.
```

## k Optimization
```{r}
fviz_nbclust(purchase_behavior, kmeans, method = "wss")
```

```{r}
fviz_nbclust(purchase_behavior, kmeans, method = "silhouette")
```

**4 to 5 clusters would seem to me to be reasonable since they would want 2 to 5 promotional approaches. Also, optimal k would be around 4 due to the "elbow" of the curve being at that point and using the information from the silhouettte method it would be at 5, however, 4 isn't much lower.**

### K-means for k = 4 & 5 Analysis

```{r}
purchases_kmeans4 <- kmeans(purchase_behavior, centers = 4, nstart = 25)
purchases_kmeans5 <- kmeans(purchase_behavior, centers = 5, nstart = 25)
```

```{r}
fviz_cluster(purchases_kmeans4, data = purchase_behavior) -> purchase_behave
purchase_behave
fviz_cluster(purchases_kmeans5, data = purchase_behavior) -> purchase_behave
purchase_behave
```

```{r}
library(cluster)
sil <- silhouette(purchases_kmeans4$cluster, dist(purchase_behavior))
fviz_silhouette(sil)

sil <- silhouette(purchases_kmeans5$cluster, dist(purchase_behavior))
fviz_silhouette(sil)
```

After looking at both k = 4 and k =5, 5 clusters seems to be better as the clusters center distances seem more widely spread out and not as close together. Also, it seems to me that the k=5 had less negative values which means they probably put more points into the right clusters. 

## Cluster Analysis
```{r}
soap$purch_behavior_cl <- purchases_kmeans5$cluster

norm_soap_centers <- as.data.frame(cbind(c(1, 2, 3, 4, 5), purchases_kmeans5$centers))

soap[, c(15:26,51)]%>%
  group_by(purch_behavior_cl) %>% 
  summarise_all(mean) -> soap_centers

library(reshape2)
cluster_mean <- melt(norm_soap_centers)
cluster_mean$cluster <- c(1,2,3,4,5)
cluster_mean$cluster <- as.factor(cluster_mean$cluster)
cluster_mean <- cluster_mean[-1:-5, ]
cluster_mean$value <- round(cluster_mean$value, 2)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
ggplot(
  cluster_mean,
  aes(variable, value, group = cluster, color = factor(cluster))) +
  geom_line() +
  scale_color_viridis_d() +
  labs(x = "Variables", y = "Normalized Value", title = "Big spenders, Want Promotions" ) +
  theme(legend.position = "right") +
  theme(axis.text.x = element_text(
    colour = "grey20", size = 12, angle = 90, hjust = 0.5, vjust = 0.5),
                        axis.text.y = element_text(colour = "grey20", size = 12),
                        strip.text = element_text(face = "italic"),
                        text = element_text(size = 16)
    ) + 
  scale_color_manual(name = "Cluster", values = c("#FF0000", "#17A589", "#D3D3D3", "#D3D3D3", "#D3D3D3"))
```

### Cluster 1
The customers in this cluster are likely to be the **big spenders**: 
  + high total volume of transactions 
  + high total value of transactions
 
### Cluster 2
The customers in this cluster are **value seekers**: 
  + won't make purchases without a promotion
  + will purchased items that have higher average prices
  

```{r, echo=FALSE, message=FALSE, warning=FALSE}
ggplot(
  cluster_mean,
  aes(variable, value, group = cluster, color = factor(cluster))
) +
  geom_line() +
  scale_color_viridis_d() +
  labs(x = "Variables", y = "Normalized Value", title = "Brand Loyal, Occasional Purchasers" ) +
  theme(legend.position = "right") +
  theme(axis.text.x = element_text(
    colour = "grey20", size = 12, angle = 90, hjust = 0.5, vjust = 0.5),
                        axis.text.y = element_text(colour = "grey20", size = 10),
                        strip.text = element_text(face = "italic"),
                        text = element_text(size = 16)
    ) + 
  scale_color_manual(name = "Cluster", values = c("#D3D3D3", "#D3D3D3", "#FF0000", "#17A589", "#D3D3D3"))
```

### Cluster 3
The customers in this cluster are **brand loyal**: 
  + most brand loyal as they purchase lowest number of brands
  + spend their money on the brands they are loyal to
  + have a higher number of transactions per brand run
  + are more brand loyal to brands with lower prices 
  + do not need promotions to buy their brands

### Cluster 4
The customers in this cluster are **occasional purchasers**: 
  + lowest number of transactions
  + lowest volume
  + lowest total value

```{r, echo=FALSE, message=FALSE, warning=FALSE}
ggplot(
  cluster_mean,
  aes(variable, value, group = cluster, color = factor(cluster))
) +
  geom_line() +
  scale_color_viridis_d() +
  labs(x = "Variables", y = "Normalized Value", title = "Brand Jumpers" ) +
  theme(legend.position = "right") +
  theme(axis.text.x = element_text(
    colour = "grey20", size = 12, angle = 90, hjust = 0.5, vjust = 0.5),
                        axis.text.y = element_text(colour = "grey20", size = 10),
                        strip.text = element_text(face = "italic"),
                        text = element_text(size = 16)
    ) + 
  scale_color_manual(name = "Cluster", values = c("#D3D3D3", "#D3D3D3", "#D3D3D3", "#D3D3D3", "#FF0000"))
```

### Cluster 5
The customers in this cluster are **not brand loyal**: 
  + Highest number of brand runs
  + highest number of transactions
  + lower transactions per brand
  + lowest percentage spent on a specific brand
  + lower volume per transaction
  + Doesn't matter as much to them to buy when there is a promotion or not
  
  
## Summary
What are the variables that best identify the clusters? Looking at the graphs of each cluster, they all seem important to distinguishing each cluster. I didn't see a variable that all the clusters were close to 0 or the normalized means were all within 1 SD from the center 0. 
  
  
  
  
  
  
  
  
  
  
# Part 2: Why Customers Buy
This segmentation is based average price and the selling propositions. 

```{r}
purchase_reason <- norm[, c(9,23:37)] # created a df based on purchase behavior variables.
```

## k Optimization
```{r}
fviz_nbclust(purchase_reason, kmeans, method = "wss")
```

```{r}
fviz_nbclust(purchase_reason, kmeans, method = "silhouette")
```

**4 to 5 clusters would seem to me to be reasonable since they would want 2 to 5 promotional approaches. Also, optimal k would be around 4 due to the "elbow" of the curve being at that point and using the information from the silhouettte method it would be at 5, however, 4 isn't much lower.**

### K-means for k = 3 & 4 Analysis

```{r}
purchases_kmeans3 <- kmeans(purchase_reason, centers = 3, nstart = 25)
purchases_kmeans4 <- kmeans(purchase_reason, centers = 4, nstart = 25)
```

```{r}
fviz_cluster(purchases_kmeans4, data = purchase_reason) -> purchase_basis
purchase_basis
fviz_cluster(purchases_kmeans3, data = purchase_reason) -> purchase_basis
purchase_basis
```

```{r}
sil <- silhouette(purchases_kmeans4$cluster, dist(purchase_reason))
fviz_silhouette(sil)

sil <- silhouette(purchases_kmeans3$cluster, dist(purchase_reason))
fviz_silhouette(sil)
```
After looking at both k = 3 and k =4, 3 clusters seems to be better as the clusters are less overlapped, clusters are more compact, and centers are spread futher apart. 

## Cluster Analysis
```{r}
soap$purch_reason_cl <- purchases_kmeans3$cluster

norm_soap_centers <- as.data.frame(cbind(c(1, 2, 3, 4, 5), purchases_kmeans3$centers))

soap[, c(9,23:37,52)]%>%
  group_by(purch_reason_cl) %>% 
  summarise_all(mean) -> soap_centers_2

cluster_mean <- melt(norm_soap_centers)
cluster_mean$cluster <- c(1,2,3)
cluster_mean$cluster <- as.factor(cluster_mean$cluster)
cluster_mean <- cluster_mean[-1:-3, ]
cluster_mean$value <- round(cluster_mean$value, 2)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
ggplot(
  cluster_mean,
  aes(variable, value, group = cluster, color = factor(cluster))) +
  geom_line() +
  scale_color_viridis_d() +
  labs(x = "Variables", y = "Normalized Value", title = "Motivated by Price Category 2 and 4, Prop Category 5") +
  theme(legend.position = "right") +
  theme(axis.text.x = element_text(
    colour = "grey20", size = 12, angle = 90, hjust = 0.5, vjust = 0.5),
                        axis.text.y = element_text(colour = "grey20", size = 12),
                        strip.text = element_text(face = "italic"),
                        text = element_text(size = 14)
    ) + 
  scale_color_manual(name = "Cluster", values = c("#FF0000", "#D3D3D3", "#D3D3D3"))
```

### Cluster 1
The customers in this cluster are likely to make purchases if: 
  + the product's price is in category 2 and 4
  + the product is more in proposition category 5 or but also 11
  + Less likely to purchase a product in price categories 1 and 3 or in proposition category 12 to 14
  

```{r, echo=FALSE, message=FALSE, warning=FALSE}
ggplot(
  cluster_mean,
  aes(variable, value, group = cluster, color = factor(cluster))
) +
  geom_line() +
  scale_color_viridis_d() +
  labs(x = "Variables", y = "Normalized Value", title = "Highly motivated by Price Category 1 & Like Most Prop Categories") +
  theme(legend.position = "right") +
  theme(axis.text.x = element_text(
    colour = "grey20", size = 12, angle = 90, hjust = 0.5, vjust = 0.5),
                        axis.text.y = element_text(colour = "grey20", size = 10),
                        strip.text = element_text(face = "italic"),
                        text = element_text(size = 12)
    ) + 
  scale_color_manual(name = "Cluster", values = c("#D3D3D3", "#FF0000", "#D3D3D3"))
```

### Cluster 2
The customers in this cluster are likely to make purchases if: 
  + the average price is higher
  + the product's price is in category 1 (highly motivated to purchase in that category)
  + makes purchases in most of the proposition cateogries
  + Less likely to purchase a product in price categories 2 to 4 or in proposition category 11 and 14
  
  
```{r, echo=FALSE, message=FALSE, warning=FALSE}
ggplot(
  cluster_mean,
  aes(variable, value, group = cluster, color = factor(cluster))
) +
  geom_line() +
  scale_color_viridis_d() +
  labs(x = "Variables", y = "Normalized Value", title = "Motivated by Price Category 2 and 4, Prop Category 5" ) +
  theme(legend.position = "right") +
  theme(axis.text.x = element_text(
    colour = "grey20", size = 12, angle = 90, hjust = 0.5, vjust = 0.5),
                        axis.text.y = element_text(colour = "grey20", size = 10),
                        strip.text = element_text(face = "italic"),
                        text = element_text(size = 12)
    ) + 
  scale_color_manual(name = "Cluster", values = c("#D3D3D3", "#D3D3D3", "#FF0000"))
```

### Cluster 3
The customers in this cluster are likely to make purchases if: 
  + the average price very low
  + the product's price is in category 2 and 4
  + Motivated to purchase in prop_cat_5

## Summary
What are the variables that identify the clusters:
  + Average Price
  + All Price Categories
  + All proposition categories except maybe numbers 9, 11, and 15 as most of the values for each cluster is close to 0, the center.






  
  
## Part 3: Purchase Behavior and Basis of Purchase
How can we use the above knowledge to create clusters that combine what we have learned so far? I am going to take the variables from both parts where at least one cluster's mean was at least 1 SD from the center, 0. The variables I will be using are all of the variables for part 1 and all the variables from part 2. I will see if removing prop_cat_9, 11, and 15 has any impact on the clusters by keeping them in and then removing them to see if there is any impact on the clusters.

```{r}
purch_behavior_basis <- norm[, c(2:13, 23:30,32,34:36)] # created a df based on purchase behavior variables.
```

## k Optimization
```{r}
fviz_nbclust(purch_behavior_basis, kmeans, method = "wss")
```

```{r}
fviz_nbclust(purch_behavior_basis, kmeans, method = "silhouette")
```

**3 to 4 clusters would seem to me to be reasonable due to the previous sections and the above measures help to confirm to start our investigation with those values for k. Also, I decided to remove prop_cat_9, 11, and 15 after running the model with them. The clusters were overlapping a lot more and were the distances of the centers were very close together.**

### K-means for k = 3 & 4 Analysis

```{r}
purchases_kmeans3 <- kmeans(purch_behavior_basis, centers = 3, nstart = 25)
purchases_kmeans4 <- kmeans(purch_behavior_basis, centers = 4, nstart = 25)
```

```{r}
fviz_cluster(purchases_kmeans4, data = purch_behavior_basis) -> purchase_behave
purchase_behave
fviz_cluster(purchases_kmeans3, data = purch_behavior_basis) -> purchase_behave
purchase_behave
```

```{r}
library(cluster)
sil <- silhouette(purchases_kmeans3$cluster, dist(purch_behavior_basis))
fviz_silhouette(sil)

sil <- silhouette(purchases_kmeans4$cluster, dist(purch_behavior_basis))
fviz_silhouette(sil)
```

After looking at both k = 3 and k =4, 3 clusters seems to be better as the clusters are more defined and there is less overlap. Also from our previous sections, three clusters would be more useful for classifying the types of customers in each.

## Cluster Analysis
```{r}
soap$purch_behavior_basis_cl <- purchases_kmeans3$cluster

norm_soap_centers <- as.data.frame(cbind(c(1, 2, 3), purchases_kmeans3$centers))

soap[, c(15:26, 36:43, 45, 47:49, 53)]%>%
  group_by(purch_behavior_basis_cl) %>% 
  summarise_all(mean) -> soap_centers

cluster_mean <- melt(norm_soap_centers)
cluster_mean$cluster <- c(1,2,3)
cluster_mean$cluster <- as.factor(cluster_mean$cluster)
cluster_mean <- cluster_mean[-1:-3, ]
cluster_mean$value <- round(cluster_mean$value, 2)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
ggplot(
  cluster_mean,
  aes(variable, value, group = cluster, color = factor(cluster))) +
  geom_line() +
  scale_color_viridis_d() +
  labs(x = "Variables", y = "Normalized Value", title = "Brand Loyal, Price Category 3, and Prop Category 14" ) +
  theme(legend.position = "right") +
  theme(axis.text.x = element_text(
    colour = "grey20", size = 12, angle = 90, hjust = 0.5, vjust = 0.5),
                        axis.text.y = element_text(colour = "grey20", size = 12),
                        strip.text = element_text(face = "italic"),
                        text = element_text(size = 12)
    ) + 
  scale_color_manual(name = "Cluster", values = c("#FF0000", "#D3D3D3", "#D3D3D3"))

soap[, c(2:10,14, 53)] %>% 
  filter(purch_behavior_basis_cl == 1) %>% 
  gather(key = Variable, value = Value) %>% 
  ggplot() +
    geom_histogram(aes(x = Value), fill = "steelblue", stat = "count") +
    facet_wrap(~Variable, scales='free') +
    theme_classic() +
    theme(aspect.ratio = 0.5, axis.title = element_blank(), panel.grid = element_blank()) 
```

### Cluster 1
The customers in this cluster are likely to be the **brand loyal** customers who: 
  + purchase items of a lower price
  + respond to products in the third price category and proposition category 14
  
 
```{r, echo=FALSE, message=FALSE, warning=FALSE}
ggplot(
  cluster_mean,
  aes(variable, value, group = cluster, color = factor(cluster))
) +
  geom_line() +
  scale_color_viridis_d() +
  labs(x = "Variables", y = "Normalized Value", title = "Brand Loyal, Occasional Purchasers" ) +
  theme(legend.position = "right") +
  theme(axis.text.x = element_text(
    colour = "grey20", size = 12, angle = 90, hjust = 0.5, vjust = 0.5),
                        axis.text.y = element_text(colour = "grey20", size = 10),
                        strip.text = element_text(face = "italic"),
                        text = element_text(size = 12)
    ) + 
  scale_color_manual(name = "Cluster", values = c("#D3D3D3", "#FF0000", "#D3D3D3"))

soap[, c(2:10,14, 53)] %>% 
  filter(purch_behavior_basis_cl == 2) %>% 
  gather(key = Variable, value = Value) %>% 
  ggplot() +
    geom_histogram(aes(x = Value), fill = "steelblue", stat = "count") +
    facet_wrap(~Variable, scales='free') +
    theme_classic() +
    theme(aspect.ratio = 0.5, axis.title = element_blank(), panel.grid = element_blank()) 
```

### Cluster 2
The customers in this cluster move around brands and: 
  + base their purchases on the price of the product
  + they are not motivated by the promotions
  + their purchases are mostly in price categories 2 and 4 and prop category 5


```{r, echo=FALSE, message=FALSE, warning=FALSE}
ggplot(
  cluster_mean,
  aes(variable, value, group = cluster, color = factor(cluster))
) +
  geom_line() +
  scale_color_viridis_d() +
  labs(x = "Variables", y = "Normalized Value", title = "Premium Customers Who Love a Good Deal" ) +
  theme(legend.position = "right") +
  theme(axis.text.x = element_text(
    colour = "grey20", size = 12, angle = 90, hjust = 0.5, vjust = 0.5),
                        axis.text.y = element_text(colour = "grey20", size = 10),
                        strip.text = element_text(face = "italic"),
                        text = element_text(size = 12)
    ) + 
  scale_color_manual(name = "Cluster", values = c("#D3D3D3", "#D3D3D3", "#FF0000"))

soap[, c(2:10,14, 53)] %>% 
  filter(purch_behavior_basis_cl == 3) %>% 
  gather(key = Variable, value = Value) %>% 
  ggplot() +
    geom_histogram(aes(x = Value), fill = "steelblue", stat = "count") +
    facet_wrap(~Variable, scales='free') +
    theme_classic() +
    theme(aspect.ratio = 0.5, axis.title = element_blank(), panel.grid = element_blank()) 

```

### Cluster 3
The customers in this cluster are **premium customers**: 
  + they purchase products that have a high average price
  + they could be more brand loyal
  + they love a good promotion
  + they love the products in price category 1 and any proposition category that is 6 to 13
  
  
  





## Part 4: Predictive Model
We need to create a model that will predict if a customer one of the three clusters.

```{r}
p <- createDataPartition(soap$purch_behavior_basis_cl,p=0.7,list=FALSE)

train <- soap[p,]
valid <- soap[-p,]
```


```{r}
library(fastDummies)
soap[, 54:57] <- dummy_cols(soap$purch_behavior_basis_cl)
## Applying logistic regression model 
lm <- glm.fit(purch_behavior_basis_cl~ .,family=binomial(link="logit"),data=soap[, c(-11:-13,-51,-52)])
summary(Logistic_Model)

## Predicting churn results based on the logistic model
predict_validation<-predict(Logistic_Model,newdata = validation_data,type='response')

## Categorizing the result based on the cutoff value(0.5)
resultcheck<-ifelse(predict_validation>0.5,1,0)
```